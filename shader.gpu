

// Vertex shader
const vertexShaderSource = `
attribute vec3 vertex, normal;
attribute vec2 texture;
uniform mat4 ModelViewProjectionMatrix;

varying vec3 normalV;
varying vec2 textureV;
uniform vec3 lightPosition;
varying vec3 toLightV;
varying vec3 toViewV;
uniform vec2 transl;
uniform float scale;

mat4 translation(vec2 t) {
    mat4 arr;

    arr[0][0] = 1.0; arr[0][ 1] = 0.0; arr[0][ 2] = 0.0; arr[0][ 3] = 0.0;
    arr[1][ 0] = 0.0; arr[1][ 1] = 1.0; arr[1][ 2] = 0.0; arr[1][ 3] = 0.0;
    arr[2][ 0] = 0.0; arr[2][ 1] = 0.0;  arr[2][ 2] = 1.0; arr[2][ 3] = 0.0;
    arr[3][ 0] = t.x; arr[3][ 1] = t.y; arr[3][ 2] = 0.0; arr[3][ 3] = 1.0;

    return arr;
}

mat4 scaling(float S){
    mat4 arr;

    arr[0][0] = S; arr[0][ 1] = 0.0; arr[0][ 2] = 0.0; arr[0][ 3] = 0.0;
    arr[1][ 0] = 0.0; arr[1][ 1] = S; arr[1][ 2] = 0.0; arr[1][ 3] = 0.0;
    arr[2][ 0] = 0.0; arr[2][ 1] = 0.0; arr[2][ 2] = S; arr[2][ 3] = 0.0;
    arr[3][ 0] = 0.0; arr[3][ 1] = 0.0; arr[3][ 2] = 0.0; arr[3][ 3] = 1.0;

    return arr;
}

void main() {
    vec4 tr1 = translation(-transl)*vec4(texture,0.0,1.0);
    vec4 tr2 = scaling(scale)*tr1;
    vec4 tr3 = translation(transl)*tr2;
    normalV = normal;
    textureV = tr3.xy;
    toLightV = lightPosition-vertex;
    toViewV = -vertex;
    gl_Position = ModelViewProjectionMatrix * vec4(vertex,1.0);
}`;


// Fragment shader
const fragmentShaderSource = `
#ifdef GL_FRAGMENT_PRECISION_HIGH
   precision highp float;
#else
   precision mediump float;
#endif

uniform vec3 lightPosition;
uniform vec3 lightDirection;
uniform float range;
uniform float focus;

varying vec3 normalV;
varying vec3 toLightV;
varying vec3 toViewV;
uniform sampler2D tmu;
varying vec2 textureV;


float Ka = 0.3;
float Kd = 0.5;
float Ks = 0.5;
float shininessVal = 30.0;
vec3 ambientColor = vec3(0.7, 0.05, 0.05);
vec3 diffuseColor = vec3(0.7, 0.7, 0.7);
vec3 specularColor = vec3(0.0, 0.0, 0.0);

uniform vec4 color;
void main() {
    vec3 toLight = normalize(toLightV);
    vec3 toView = normalize(toViewV);
    vec3 N = normalize(normalV);
    vec3 halfVector = normalize(toLight + toView);
    float dotFromDirection = dot(toLight,-lightDirection);
    float inLight = smoothstep(range-focus,range, dotFromDirection);
    float light = inLight * dot(N, toLight);
    float specular = inLight * pow(dot(N, halfVector), 100.0);

    vec3 ambient = Ka * ambientColor;
    vec3 diffuse = Kd  * diffuseColor;
    vec3 phong = Ks * specular * specularColor;

    vec3 finalColor = ambient + diffuse + phong;

    vec4 texColor = texture2D(tmu,textureV);
    gl_FragColor = texColor*light;

    
   
    
}`;